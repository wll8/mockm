# 配置项
## config.osIp
类型: string  
默认: 内网网卡第一个 IP  

想绑定到 pm 程序的 IP, 会自动添加到[调试链接](#configtestprot)中.

## config.prot
类型: number  
默认: 9000  

服务端口, 用于接口调用.


## config.replayProt
类型: number  
默认: 9001  

重放端口, 用于使用服务端口产生的缓存数据.

## config.replayProxy 
类型: boolean  
默认: true  

记录中不存在所需请求时, 是否转发请求到 [proxy](#configProxy).

## config.replayProxyFind
类型: function  
默认:   
``` js {4}
replayProxyFind (item) { // 选择响应体中 body.status 为 200 的数据
  const bodyPath = require(`path`).join(process.cwd(), item.data.res.bodyPath)
  const body = require(bodyPath)
  return body.status === 200 || body.status === `200`
}
```

自定义请求重放时的逻辑, 则怎样的缓存记录会被返回, 如果自定义逻辑没有找到, 会返回 http 状态码为 200 的第一条数据, 或历史记录中的第一条.

## config.testProt
类型: number  
默认: 9005  

调试端口, 用于生成测试页面服务

## config.updateToken
类型: boolean/string  
默认: true  

是否自动从 req 中获取最新 token 然后替换到重发请求的 authorization 上, 为 string 时为自定义 header 字段.

## config.apiInHeader
类型: boolean/string  
默认: true  

是否在 header 中添加调试 api 地址, string 时为自定义 header 字段.

## config.proxy
类型: string/object  
默认:  
``` js
proxy: { // string | object
  '/': `http://www.httpbin.org/`, // `/` 键是必须存在的
  '/get': { // 使用配置, 参考 https://github.com/chimurai/http-proxy-middleware#http-proxy-options
      onProxyReq (proxyReq, req, res) { // 拦截请求
        proxyReq.setHeader('x-added', 'req')
      },
      mid (req, res, next) { // 在进行代理之前添加中间件
        setTimeout(next, 5000) // 延时
      },
      onProxyRes (proxyRes, req, res) { // 拦截响应
        proxyRes.headers['x-added'] = 'res'
      },
  },
},
```

代理到远程的目标域名，为对象时每个键是分别对应一个要自定义代理的路由. 注: 是对象时, 需要存在键 `/` 表示默认域名.  

此功能可以自定义拦截过程, 类似 webpack 中的 `devServer.proxy` . 

string 的时候相当于请求转发. object 相当于传入 proxy 的配置. 

proxy 配置参考 https://github.com/chimurai/http-proxy-middleware#http-proxy-options 


支持已简便的方式快速处理 json 格式的 response, 使用数组语法: `[A, B]`.  
数组中不同个数和类型有不同的处理方式.  

| 个数  | A 值类型 | B 值类型 | 处理方式                                | 示例                          | 处理前              | 处理后                    |
| ----- | -------- | -------- | --------------------------------------- | ----------------------------- | ------------------- | ------------------------- |
| 0 或1 | any      |          | 直接替换                                | `[]` 或 `[undefined]`         | `{a: 1}`            |
|       |          |          |                                         | `[123]`                       | `{a: 1}`            | 123                       |
| 2     | string   | any      | A 是对象的 key, 把 key 对应的值替换为 B | `['a', 2]`                    | `{a: 1}`            | `{a: 2}`                  |
|       |          |          |                                         | `['a.b', undefined]`          | `{a: {b: 1, c: 2}}` | `{a: {c: 2}}`             |
| 2     | object   | `...`    | 合并, 父级`会`被替换                    | `[{a: {b: 2}, c: 1}, '...']`  | `{a: {a: 1}}`       | `{a: {b: 2}, c: 1}`       |
| 2     | object   | `deep`   | 合并, 父级`不会`被替换                  | `[{a: {b: 2}, c: 1}, 'deep']` | `{a: {a: 1}}`       | `{a: {a: 1, b: 2}, c: 1}` |


例:

``` js
proxy: { // string | object
  '/': `http://www.httpbin.org/`, // 
  // '/get': [`origin`, `127.0.0.1`], // 第二个值存在, 以第二个值替换 origin, 第二个值为 undefined 时相当于删除
  // '/get': [{msg: `ok`}], // 只有0个或一个值, 直接替换 res
  // '/get': [{origin: `127.0.0.1`, msg: `ok`, headers: {tips: `mid`}}, `deep`], // 合并: [要合并的对象, 合并的方式], 合并的方式: deep(父级不会被替换), ...(父级会被替换, 类似于js扩展运行符)
},

```

可以方便的支付任意路径转发, 以下演示转发到其他域名:
``` js
proxy: {
  // 可以直接转发到任意 http 链接
  '/get': `https://www.httpbin.org/ip`,
},
```

## config.remote
类型: boolean/object  
默认: false  
注: 重启生效  

- [ ] remote.object 支持

是否映射本地服务到公网.

这里默认使用 ngrok 的免费服务, 值为 object 时是对每个服务端口的配置.

ngrok 配置参考: https://ngrok.com/docs#tunnel-definitions

例:
``` js
remote: {
  authtoken: `******`,
  tunnels: {
    testProt: { proto: `http` }, // 配置 testProt 的映射方式
    otherProt: { // 映射其他的外网服务, 你不必自己安装 ngrok 即可实现
      addr: 8080
    },
  },
}
```

## config.openApi
类型: string|array|object
默认: `http://httpbin.org/spec.json` 

- [ ] yaml 支持
- [ ] 数组支持
- [ ] 对象支持

关联的 openApi 数据文件, 支持 yaml/json 格式, 支持多个. 如果一个系统分为多个 swagger 文档, 当分配为数组的时候, 会自动根据当前的 api 匹配对应的 swagger 文档.
如果为对象的时候, 键作为匹配模式.


## config.dataDir
类型: string  
默认: `./httpData/`  

http 请求数据保存目录.

## config.httpHistory
类型: string  
默认: `./httpData/httpHistory.json`  

- [ ] 移除

录制信息保存位置.

## config.store
类型: string  
默认: `./httpData/store.json`  

- [ ] 移除

程序内置计数器, 不支持修改.

``` js
{
  "apiCount": 42, // api 请求数
  "note": { // 备忘录, 如果忘记启动时的服务, 可以到这里查看
    "remote": {}, // 外网服务链接
  }
}
```

## config.cors
类型: boolean  
默认: true  

是否允许通过跨域.

## config.api
类型: object|function  
默认:   

``` js
api (util) {
  const { run } = util
  return { // 自建 api, 不会发送请求到 proxy 服务器
    '/' (req, res, next) { // 在所有自定义 api 之前添加中间件
      // 注意, 如果不 next 将不会进入后面的中间件
      // 如果需要拦截所有到达服务器前的请求, 请从 config.proxy 中配置
      next()
    },
    '/all/method' (req, res, next) { // 所有方法都会进入此路由
      res.json({msg: req.method, url: req.url})
    },
    'get /json': { // 直接返回 json 数据
      msg: `json api`
    },
    'get /file' (req, res, next) { // 发送文件
      res.sendFile(`${__dirname}/readme.md`)
    },
    'get /status/:code' (req, res, next) { // 使用 params 参数
      res.statusCode = req.params.code
      res.json(req.params)
    },
    'get /curl' (req, res, next) { // 输出 curl/bash 命令的执行结果
      run.curl({req, res, cmd: `curl 'http://www.httpbin.org/ip'`}).then(curRes => {
        res.send(curRes.body)
      })
    },
    'get /fetch' (req, res, next) { // 使用 node-fetch 的执行结果
      run.fetch({
        req,
        res,
        fetchRes: fetch(`http://www.httpbin.org/ip`)
      }).then(async thenRes => {
        const thenResOk = await thenRes.buffer()
        res.send(thenResOk)
      })
    },
  }
},
```

自建 api, 为 function 时, 可以获取提供的常用 util. 对象的 key 为 api 路由.

## config.dbJsonName
类型: string  
默认: `./httpData/db.json`  

- [ ] 移除

json 数据生成的保存位置.

## config.dbCover
类型: boolean  
默认: false  

- false: 如果是 db 中不存在的 key, 则添加, 如果存在, 不做任何改变
- true: 总是覆盖 db


## config.db
类型: object|function  
默认: {}  

供 json-server 使用的 json 数据.


## config.route
类型: object
默认: 
``` js
route: {
  // 路由映射, 作用于 config.api 及 config.db 产生的 api
  // 参考: https://github.com/typicode/json-server#add-custom-routes
  '/db/api/*': '/$1', // /api/a => /a
},
```

路由映射, 作用于 config.api 及 config.db 产生的 api  
参考: https://github.com/typicode/json-server#add-custom-routes  

## config.resHandleReplay
类型: function 
默认: 
``` js
resHandleReplay({req, res}) {
  // 处理重放请求出错时会进入这个方法
  // 对于没有记录 res 的请求, 返回 404 可能会导致前端页面频繁提示错误(如果有做这个功能)
  // 所以这里直接告诉前面接口正常(200ok), 并返回前约定的接口数据结构, 让前端页面可以尽量正常运行
  res.statusCode = 200
  return {
    code: res.statusCode,
    success: Boolean(('' + res.statusCode).match(/^[2]/)), // 如果状态码以2开头则为 true
    data: {},
  }
},
```

## config.resHandleJsonApi
类型: function 
默认: 
``` js
resHandleJsonApi({req, res, data}) {
  // 由 db 生成的接口的最后一个拦截器
  // 可以用来构建项目所需的数据结构
  return {
    code: res.statusCode,
    success: Boolean(('' + res.statusCode).match(/^[2]/)), // 如果状态码以2开头则为 true
    data,
  }
},
```
