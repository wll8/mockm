# 配置项

## config.osIp
类型: string
默认: 内网网卡第一个 IP

想绑定到 pm 程序的 IP, 会自动添加到[调试链接](#configtestprot)中.

## config.prot
类型: number/string
默认: 9000

服务端口, 用于接口调用.

## config.replayProt
类型: number/string
默认: 9001

重放端口, 用于使用服务端口产生的缓存数据.

## config.replayProxy
类型: boolean
默认: true

记录中不存在所需请求时, 是否转发请求到 [proxy](#configProxy).

- false 不转发
- true 转发

## config.replayProxyFind
类型: function
默认:

```js {4}
replayProxyFind (item) { // 选择响应体中 body.status 为 200 的数据
  const bodyPath = require(`path`).join(process.cwd(), item.data.res.bodyPath)
  const body = require(bodyPath)
  return body.status === 200 || body.status === `200`
}
```

自定义请求重放时的逻辑, 则怎样的缓存记录会被返回, 如果自定义逻辑没有找到, 会返回 http 状态码为 200 的第一条数据, 或历史记录中的第一条.

## config.testProt
类型: number/string
默认: 9005

调试端口, 用于生成测试页面服务

## config.updateToken
类型: boolean/string
默认: true

是否自动从 req 中获取最新 token 然后替换到重发请求的 authorization 上.

- false 不添加
- true 自动添加
- string 自定义 header 字段

## config.apiInHeader
类型: boolean/string
默认: true

是否在 header 中添加调试 api 地址.

- false 不添加调试地址
- true 时 `x-test-api`.
- string: 时为自定义 header 字段.

## config.proxy
类型: string/object
::: details 默认
```js
proxy: { // string | object
  '/': `http://www.httpbin.org/`, // `/` 键是必须存在的
  '/get': { // 使用配置, 参考 https://github.com/chimurai/http-proxy-middleware#http-proxy-options
      onProxyReq (proxyReq, req, res) { // 拦截请求
        proxyReq.setHeader('x-added', 'req')
      },
      mid (req, res, next) { // 在进行代理之前添加中间件
        setTimeout(next, 5000) // 延时
      },
      onProxyRes (proxyRes, req, res) { // 拦截响应
        proxyRes.headers['x-added'] = 'res'
      },
  },
},
```

:::


代理到远程的目标域名，为对象时每个键是分别对应一个要自定义代理的路由. 注: 是对象时, 需要存在键 `/` 表示默认域名.
此功能可以自定义拦截过程, 类似 webpack 中的 `devServer.proxy` .

- string 直接请求转发到指定地址. 
- object 相当于传入 proxy 的配置.

proxy 配置参考 https://github.com/chimurai/http-proxy-middleware#http-proxy-options

### 快速修改 json response

支持以简便的方式快速处理 json 格式的 response, 使用数组语法: `[A, B]`.
数组中不同个数和类型有不同的处理方式, 参考下表:

| 个数 | [A, B] 类型      | 处理方式       | 示例                          | 处理前              | 处理后                    |
| ---- | ---------------- | -------------- | ----------------------------- | ------------------- | ------------------------- |
| 0, 1 | [any]            | 直接替换       | `[]` 或 `[undefined]`         | `{a: 1}`            |
|      |                  |                | `[123]`                       | `{a: 1}`            | 123                       |
| 2    | [string, any]    | 替换指路径的值 | `['a', 2]`                    | `{a: 1}`            | `{a: 2}`                  |
|      |                  |                | `['a.b', undefined]`          | `{a: {b: 1, c: 2}}` | `{a: {c: 2}}`             |
| 2    | [object, `...`]  | 浅合并         | `[{a: {b: 2}, c: 1}, '...']`  | `{a: {a: 1}}`       | `{a: {b: 2}, c: 1}`       |
|      | [object, `deep`] | 深合并         | `[{a: {b: 2}, c: 1}, 'deep']` | `{a: {a: 1}}`       | `{a: {a: 1, b: 2}, c: 1}` |

::: details 示例
进一步解释表格中的示例.

**直接替换**

```txt
处理前
{
  "a": 1
}

操作, 直接替换为空
[] 或 [undefined]

处理后
undefined
```

**直接替换**

```txt
处理前
{
  "a": 1
}

操作, 直接替换为 123
[123]

处理后
123
```

**替换指定路径的值**

```txt
处理前
{
  "a": 1
}

操作, 把 a 的值替换为 2
['a', 2]

处理后
{
  "a": 2
}
```

**替换指定路径的值**

```txt
处理前
{
  "a": {
    "b": 1,
    "c": 2
  }
}

操作, 把 a 下面 b 的值删除
['a.b', undefined]

处理后
{
  "a": {
    "c": 2
  }
}
```

**浅合并**

```txt
处理前
{
  "a": {
    "a": 1
  }
}

操作, 合并时直接替换
[
  {
    "a": {
      "b": 2
    },
    "c": 1
  },
  "..."
]

处理后
{
  "a": {
    "b": 2
  },
  "c": 1
}
```

**深合并**

```txt
处理前
{
  "a": {
    "a": 1
  }
}

操作, 深层合并对象
[
  {
    "a": {
      "b": 2
    },
    "c": 1
  },
  "deep"
]

处理后
{
  "a": {
    "a": 1,
    "b": 2
  },
  "c": 1
}
```

:::

### 免路由重写
可以方便的支付任意路径转发, 以下演示转发到其他域名:

```js {3}
proxy: {
  '/': `http://www.httpbin.org/`,
  '/get': `https://www.httpbin.org/ip`,
},
```

## config.remote
类型: boolean/object
默认: false
注: 此修改需要重启才能生效.

是否映射本地服务到公网.

这里默认使用 ngrok 的免费服务. 值为 object 时是

- false 不启用.
- true 启用.
- object 启用并对每个服务进行配置.

ngrok 配置参考: https://ngrok.com/docs#tunnel-definitions

例:
```js
remote: {
  authtoken: `******`, // 配置 ngrok 用户权限
  tunnels: {
    testProt: { proto: `http` }, // 配置 testProt 的映射方式
    otherProt: { // 映射其他的外网服务, 你不必自己安装 ngrok 即可实现
      addr: 8080
    },
  },
}
```

- [ ] frp 支持正在规划中

## config.openApi
类型: string|array|object
默认: `http://httpbin.org/spec.json`

关联的 openApi 数据文件, 支持 yaml/json 格式, 支持多个. 如果一个系统分为多个 swagger 文档, 当分配为数组的时候, 会自动根据当前的 api 匹配对应的 swagger 文档.
如果为对象的时候, 键作为匹配模式.

- string 单个地址, 使用当前请求的 path 与该 openApi 中的 path 匹配
- [ ] array 以单个地址的方式依次进行匹配
- [ ] object 对象的 key 作为匹配方式, 对象的值可以是 string/array

## config.dataDir
类型: string
默认: `./httpData/`

http 请求数据保存目录.

## config.cors
类型: boolean
默认: true

是否允许通过跨域.

- true 自动允许跨域
- false 不对源跨域方式做任何处理

## config.api
类型: object|function
::: details 默认
```js
api (util) {
  const { run } = util
  return { // 自建 api, 不会发送请求到 proxy 服务器
    '/' (req, res, next) { // 在所有自定义 api 之前添加中间件
      // 注意, 如果不 next 将不会进入后面的中间件
      // 如果需要拦截所有到达服务器前的请求, 请从 config.proxy 中配置
      next()
    },
    '/all/method' (req, res, next) { // 所有方法都会进入此路由
      res.json({msg: req.method, url: req.url})
    },
    'get /json': { // 直接返回 json 数据
      msg: `json api`
    },
    'get /file' (req, res, next) { // 发送文件
      res.sendFile(`${__dirname}/readme.md`)
    },
    'get /status/:code' (req, res, next) { // 使用 params 参数
      res.statusCode = req.params.code
      res.json(req.params)
    },
    'get /curl' (req, res, next) { // 输出 curl/bash 命令的执行结果
      run.curl({req, res, cmd: `curl 'http://www.httpbin.org/ip'`}).then(curRes => {
        res.send(curRes.body)
      })
    },
    'get /fetch' (req, res, next) { // 使用 node-fetch 的执行结果
      run.fetch({
        req,
        res,
        fetchRes: fetch(`http://www.httpbin.org/ip`)
      }).then(async thenRes => {
        const thenResOk = await thenRes.buffer()
        res.send(thenResOk)
      })
    },
  }
},
```

:::

自建 api.

- object 对象的 key 为 api 路由.
- function 可以获得工具库, 参考 [config.api.fn](/config/config_api_fn.html#ut). 函数应返回一个对象.

当与 config.proxy 中的路由冲突时, config.api 优先.

## config.dbJsonPath
类型: string
默认: `${config.dataDir}/db.json`

json 数据生成的保存位置.

## config.dbCover
类型: boolean
默认: false

是否在重载时重新根据 config.db 生成新的数据文件.

- false 不重新生成, 但会补充新添加的数据
- true 总是重新生成

::: details FQA
### 修改了 config.db 中的深层对象的属性没有生效
于对象的数据已经生成了, 改变对象中的某个属性, 这个对象也不会改变.
如果需要改变, 删除 config.dbJsonPath 文件中的对应的对象, 再保存一下 mm.config.js 即可.

:::

## config.db
类型: object|function
::: details 默认
```js
db () {
  const data = mockjs.mock({
    'books|3-7': [
      {
        'id|+1': 1,
        num: mockjs.Random.natural(1, 10),
        title: '@ctitle',
      }
    ],
  })
  return data
},
```

:::

供 json-server 使用的 json 数据.

- object 直接作为数据使用
- function 应返回一个对象

## config.route
类型: object
路由映射, 作用于 config.api 及 config.db 产生的 api
参考: https://github.com/typicode/json-server#add-custom-routes

::: details 默认
```js
route: {
  '/db/api/*': '/$1', // /api/a => /a
},
```

:::

路由映射, 作用于 config.api 及 config.db 产生的 api
参考: https://github.com/typicode/json-server#add-custom-routes

## config.resHandleReplay
类型: function
处理重放请求出错时会进入这个方法.

::: details 默认
```js
resHandleReplay({req, res}) {
  // 对于没有记录 res 的请求, 返回 404 可能会导致前端页面频繁提示错误(如果有做这个功能)
  // 所以这里直接告诉前面接口正常(200ok), 并返回前约定的接口数据结构, 让前端页面可以尽量正常运行
  res.statusCode = 200
  return {
    code: res.statusCode,
    success: Boolean(('' + res.statusCode).match(/^[2]/)), // 如果状态码以2开头则为 true
    data: {},
  }
},
```

:::

## config.resHandleJsonApi
类型: function
由 config.db 生成的接口的最后一个拦截器, 可以用来构建项目所需的数据结构.

::: details 默认
```js
resHandleJsonApi({req, res, data}) {
  return {
    code: res.statusCode,
    success: Boolean(('' + res.statusCode).match(/^[2]/)), // 如果状态码以2开头则为 true
    data,
  }
},
```

:::
